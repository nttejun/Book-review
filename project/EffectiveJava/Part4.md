<h5>4장 클래스와 인터페이스</h5>

클래스와 인터페이스는 자바 프로그래밍 언어의 핵심부분으로
추상화(abstraction)의 기본 단위입니다

---

<h5>학습목표</h5>

자바 언어는 클래스와 인터페이스를 설계시 이용할 수 있는 강력한 요소가 많다
이 강력한 요소들을 알아보는 것이 목표다

---

<h5>규칙13 - 클래스와 멤버의 접근 권한은 최소화하라</h5>

잘 설계된 모듈과 그렇지 못한 모듈 구별 짓는 가장 중요한 속성

모듈 내부 데이터와 구현 세부사항을 다른 모듈에 잘 감추었는지 여부

잘 설계된 모듈은 구현 세부사항은 전부 API 뒤쪽에 감춘다

모듈들은 이 API를 통해서만 통신하며, 내부적으로 무슨 짓을 하는지는 신경쓰지 않습니다

이 개념이 정보은닉 또는 캡슐화라는 용어이며,

이것이 소프트웨어 설계 기본 원칙 가운데 하나입니다

---

<h5>정보은닉의 중요성</h5>

시스템을 구성하는 모듈 사이 의존성을 낮춰, 각자 개별적으로 개발을 시험하고, 최적화하고, 이해하고, 변경할 수 있도록 한다는 사실에 기초합니다

---

<h5>정보은닉 시</h5>

시스템 개발 속도가 올라가며, 각 모듈을 병렬적(?)으로 개발할 수 있기 때문입니다

유지보수 부담도 낮아집니다. 모듈 각각을 좀 더 빨리 이해할 수 있을 뿐 아니라 다른 모듈에 영향을 끼칠 걱정이 없어 디버깅을 진행할 수 있기 때문입니다.

정보은닉 원칙이 좋은 성능을 자동으로 보장하는 것은 아니지만 효과적인 성능 튜닝(tuning)(?)을 가능하게 하는 것은 사실입니다

시스템이 완성된 다음에 어떤 모듈이 성능 문제를 일으키는지 프로파일링(profiling)(?)이 용이하기 때문입니다

해당 모듈은 다른 모듈과는 관계없이 최적화할 수 있습니다

소프트웨어 재사용의 가능성을 높입니다. 모듈간 의존성이 낮아 각 모듈은 다른 소프트웨어 개발에도 유용하게 사용이 가능합니다

대규모 시스템 개발 과정의 위험성(risk)도 낮춥니다. 전체 시스템은 성공적이지 않아도 각 모듈은 성공적으로 구현될 수 있기 때문입니다

---

<h5>자바는 정보 은닉 원칙을 실현할 수 있도록 다양한 도구들을 갖추고 있습니다</h5>

접근제어 메커니즘은 클래스와 인터페이스, 그리고 그 멤버들의 접근 권한을 규정합니다

어떤 개체(entity)(?)의 접근 권한은 해당 개체가 선언된 위치와 권한 수정자(access modifier)에 의해 결정됩니다 (권한 수정자 : private, protected, public 등)

권한 수정자의 적절한 사용은 정보은닉 실현의 핵심적 부분입니다

---

<h5>정보은닉 원칙</h5>

각 클래스와 멤버는 가능한 한 접근 불가능하도록 만듭니다
(이 뜻은 개발 중인 소프트웨어의 정상적인 동작을 보증하는 한도 내 가장 낮은 접근 권한을 설정하는 것입니다)

최상위 레벨 (중첩되지 않은) 클래스와 인터페이스에 부여할 수 있는 접근 권한은 package-private와 pulbic 두 가지 입니다.

최상위 레벨 클래스와 인터페이스에 public 수정자를 붙이면 해당 개체는 전역적 개체가 됩니다

public을 붙이지 않으면 해당 패키지 안에서만 유효한 개체가 됩니다

최상위 레벨 클래스나 인터페이스는 가능한 package-private로 선언해야 합니다

package-private로 선언하면 API 일부가 아니라 구현 세부사항에 속하게 되어, 다음번 릴리스(?)에 클라이언트 코드를 깨뜨릴 걱정 없이 자유로이 변경, 삭제, 대체할 수 있게 됩니다

public으로 선언하게 되면 호환성을 보장하기 위해 해당 개체를 계속 지원해야 합니다

만일 package-private로 선언된 최상위 클래스나 인터페이스를 사용하는 클래스, 즉 사용자 클래스가 하나뿐이라면, 해당 최상위 레벨 클래스를 사용자 클래스의 private 중첩(?) 클래스로 만들 것을 고려하는 것이 좋습니다. 그러면 패키지 전체가 아니라 단 하나의 클래스만이 해당 클래스의 접근 권한을 갖게 됩니다

하지만 최상위 레벨 package-private 클래스의 접근 권한을 낮추는 것보다 public 클래스의 접근 권한을 낮추는 것이 더 중요합니다

최상위 package-private 클래스는 이미 구현 세부사항일 뿐이지만 public 클래스는 해당 패키지 API의 일부이기 때문입니다

---

<h5>필드나 메서드, 중첩 클래스(nested class), 중첩 인터페이스 같은 멤버의 접근 권한 설정 4가지</h5>

private : 이렇게 선언된 멤버는 최상위 레벨 클래스 내부에서만 접근 가능하다
package-private : 이렇게 선언된 멤버는 같은 패키지 내의 아무 클래스나 사용할 수 있다. 기본 접근 제한(default access)로 알려져 있는데, 멤버를 선언할 때 아무런 접근 권한 수정자도 붙이지 않으면, 이 권한이 주어진다
protected : 이렇게 선언된 멤버는 선언된 클래스 및 그 하위 클래스만 사용할 수 있습니다. 선언된 클래스와 같은 패키지에 있는 클래스에서도 사용이 가능합니다
public : 이렇게 선언된 멤버는 어디서도 사용가능

---

클래스의 public API를 주의 깊게 설계한 뒤 반사적으로 다른 모든 멤버는 private로 선언하게 될 것입니다. 같은 패키지 내 다른 클래스가 반드시 사용해야 하는 멤버의 경우는 private을 제거해서 해당 멤버를 package-private로 만들어야 합니다. 그런데 그런 변경 작업을 자주 하게 된다면 시스템 설계를 재검토해서 클래스 간 의존성을 좀 더 잘 끊어낼 방법은 없는지 따져봐야 합니다. private와 package-private 멤버들은 클래스의 구현 세부사항이며 공개 API의 일부가 아니지만 Serializable(?)을 구현하는 클래스의 멤버라면 공개 API 속으로 새어나갈 수도 있습니다

public 클래스의 멤버들의 경우 접근 권한을 package-private에서 protected로 변경하면 멤버를 사용할 수 있는 범위가 엄청 넓어진다. protected로 선언한 멤버는 해당 클래스의 공개 API이며, 영원히 유지해야 한다

또한 공개된 클래스의 protected 멤버는 해당 클래스의 구현 세부사항에 대한 공개적 약속과도 같다. 그러므로 protected 멤버 사용은 자제해야 한다

메서드 접근 권한을 줄일 수 없는 경우가 하나 더 있다

상위 클래스 메서드를 재정의 할 시 원래 메서드의 접근 권한보다 낮은 권한을 설정할 수 없다. 상위 클래스 객체를 사용할 수 있는 곳에는 하위 클래스 객체도 사용할 수 있어야 하기 때문이다. 이 규칙을 어기면 컴파일 오류가 발생한다

특정 인터페이스를 구현하는 클래스를 만들 때는 인터페이스에 속한 모든 메서드를 해당 클래스의 public 메서드로 선언해야 한다. 인터페이스의 모든멤버는 원래 public이기 때문이다

테스트 때문에 인터페이스, 또는 멤버들의 접근 권한을 열어주고 싶을 때도 있습니다. 어느 선 까지는 괜찮습니다. 테스트를 위해 public 클래스의 private 멤버를 package-private로 만드는 것 까지는 괜찮지만 그 이상은 곤란합니다.

테스트를 위한 것이라고 해도 클래스나 인터페이스, 멤버를 패키지의 공개 API로 만드는 것은 곤란합니다

테스트를 테스트 대상 패키지의 일부로 실행할 수 있기 때문에 package-private 정도면 충분합니다

객체 필드(instance field)는 절대 public을 선언하면 안됩니다

비-final 필드나 변경 가능 객체에 대한 final 참조 필드를 public으로 선언하면, 필드에 저장될 값을 제한할 수 없게 됩니다. 따라서 그 필드에 관계된 불변식을 강제할 수 없습니다. 필드가 변경될 때 특정한 동작이 실행되도록 할수도 없으므로, 변경 가능 public 필드를 가진 클래스는 다중 스레드에 안전하지 않습니다. 변경 불가능 객체를 참조하는 final 필드라 해도 public으로 선언하면 클래스의 내부 데이터 표현 형태를 유연하게 바꿀 수 없게 됩니다. 공개 API의 일부가 되어, 삭제 수정할 수 없게 되는 것입니다

이 이야기는 static으로 선언된 필드에도 적용되지만 한 가지 예외가 있습니다. 어떤 상수들이 클래스로 추상화된 결과물의 핵심적 부분을 구성한다고 판단되는 경우, 해당 상수들은 public static final 필드들로 선언해 공개할 수 있습니다. 이런 필드들은 관습적으로 대문자로 구성된 이름을 가지며, 이름을 구성하는 단어들은 밑줄 기호로 구분합니다. 이런 필드들은 반드시 기본 자료형 값을 갖거나, 변경 불가능 객체를 참조해야 합니다

변경 가능 객체를 참조하는 final 필드는 비-final 필드의 단점들을 그대로 갖고 있습니다. 참조 자체는 변경할 수 없지만 참조 대상 객체는 변경할 수 있으므로 끔찍한 결과가 초래됩니다.

길이가 0 아닌 배열은 언제나 변경 가능하므로, public static final 배열 필드를 두거나, 배열 필드를 반환하는 접근자를 정의하면 안됩니다. 그런 멤버를 두면 클라이언트가 배열 내용을 변경할 수 있게 되므로, 보안에 문제가 생깁니다

public static final Thing[] VALUES = { ... } ; // 보안 문제 초래 코드

많은 IDE들이 private로 선언된 배열 필드에 대한 참조를 반환하는 접근자를 자동 생성하므로 주의해야 한다

---

<h5>위 문제를 고치는 방법 2가지</h5>

public으로 선언되었던 배열은 private로 바꾸고 , 변경이 불가능한 public 리스트를 하나 만드는 것입니다.

    private static final Thing[] PRIVATE_VALUES = {...};

    public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

배열은 private 선언하고, 해당 배열을 복사해 반환하는 public 메서드를 하나 추가하는 것입니다

    private static final Thing[] PRIVATE_VALUES = {...};

    public static final Thing[] values() {

    return PRIVATE_VALUES.clone();

    }

두 방법 중 하나를 택할 때는, 클라이언트가 어떤 작업을 하길 원하는지 생각해야 한다

어떤 자료형으로 반환해야 클라이언트가 편할 것인가?

어느 쪽이 좀 더 나은 성능을 보장할 것인가?

요약하면

접근 권한은 가능한 낮추라

최소한의 public API를 설계한 다음

다른 모든 클래스, 인터페이스, 멤버는 API에서 제외하라

public static final 필드를 제외한 어떤 필드도 public 필드로 선언하지 마라

public static final 필드가 참조하는 객체는 변경 불가능 객체로 만들다

---

<h5>규칙 14 - public 클래스 안에는 public 필드를 두지말고 접근자 메서드를 사용해라</h5>

필드를 모으는 것 말고는 아무 기능이 없는 쓰레기 클래스를 만들고 싶다면
    class Point {
        public double x;
        public double y;
    }

이런 클래스는 데이터 필드를 직접 조작할 수 있어서 캡슐화의 이점을 누릴수가 없다

API를 변경하지 않고서는

내부 표현을 변경할 수 없고,

불변식(invariant)도 강제할 수 없고,

필드를 사용하는 순간에 어떤 동작이 실행되도록 만들 수도 없다

객체지향 개념에 충실하고자 하는 프로그래머에게 이런 클래스는 저주와도 같다

private 필드와 public 접근자 메서드(getter)로 바꿔야 마땅하다

변경 가능 클래스라면 수정자(mutato) 메서드(setter)도 제공해야 한다

    // 접근자 메서드와 수정자를 이용한 데이터 캡슐화
    class Point {
        private double x;
        private double y;

        public Point(double x, double y) {
            this.x = x;
            this.y = y;
        }

        public double getX() { return x; }
        public double getY() { return y; }

        public void setX(double x) { this.x = x; }
        public void setY(double y) { this.y = y; }
    }

public 클래스라면 당연히 위와 같이 코딩해야 한다

선언된 패키지 밖에서도 사용 가능한 클래스에는 접근자 메서드를 제공하라. 그래야 클래스 내부 표현을 자유로이 수정할 수 있게 된다. public 클래스의 데이터 필드를 공개하게 되면, 그 내부 표현을 변경할 수 없게 된다. 변경하면 이미 작성된 클라이언트 코드를 깨뜨리기 때문이다

하지만 package-private 클래스나 private 중첩클래스는 데이터 필드를 공개하더라도 잘못이라 말할 수 없다.

클래스가 추상화하려는 내용을 제대로 기술하기만 한다면 말이다

이 접근법은 클래스 정의, 클라이언트 코드로 보나, 접근자 메서드보다는 시각적으로 깔끔하게 보인다

클라이언트 코드가 클래스 내부 표현에 종속된다는 문제가 있긴 하지만, 클라이언트 코드가 같은 패키지 안에 있을 수 밖에 없다는 점은 고려해야 한다

클래스 내부 표현을 변경해도 패키지 외부 코드는 변경되지 않을 것이다. private 중첩 클래스의 경우에는, 그 클래스의 바깥 클래스 외부의 코드는 아무 영향을 받지 않을 것입니다

자바 플랫폼이 제공하는 라이브러리 클래스 가운데는, public 클래슨느 필드를 외부에 직접 공개하지 말아야 한다는 원칙을 따르지 않는 것이 몇 개 있습니다

java.awk 패키지에 포함된 Point와 Dimension(?) 클래스

이런 클래스는 참고하지 않는 것이 좋다

Dimension 클래스가 내부 표현을 공개한 것은 아직까지도 해결되지 않고 있는 심각한 성능 문제가 있기 때문입니다

public 클래스가 내부 필드를 외부로 공개하는 것은 바람직하지 않지만, 변경 불가능 필드는 그 심각성은 조금 덜합니다
// 변경 불가능 필드를 외부로 공개하는 public 클래스 - 정말 이래야 하는지는 의문
API를 수정하지 않고는 내부 표현을 변경할 수 없고
필드에 접근하는 순간 어떤 동작이 실행되게 만들 수도 없지만
불변식을 강제할 수는 있습니다.
예를들어 아래 클래스는 모든 객체가 올바른 시간을 나타내도록 보장합니다

    public final class Time {
      private static final int HOURS_PER_DAY = 24;
      private static final int MINUTE_PER_HOUR = 60
      public final int hour;
          public final int minute;
      public Time(int hour, int minute) {
           if (hour < 0 || hour >= HOURS_PER_DAY)
         throw new IllegalArgumentException("Hour : " + hour);
       if (minute < 0 || minute >= MINUTE_PER_HOUR)
         throw new IllegalArgumentException("Min : " + minute);
       this.hour = hour;
       this.minute = minute;
       }
    생략
    }

요약하면 public 클래스는 변경 가능 필드를 외부로 공개하면 안된다
변경 불가능 필드인 경우에는 외부로 공개하더라도 많이 위험하지 않지만, 그럴 필요가 있는지는 여전히 의문이다
하지만 package-private나 private로 선언된 중첩 클래스의 필드는 그 변경 가능 여부와는 상관없이 외부로 공개하는 것이 바람직할 때도 있다

---

<h5>규칙 15 - 변경가능성을 최소화하라</h5>

변경 불가능 클래스는 그 객체를 수정할 수 없는 클래스 입니다

객체 내부의 정보는 객체가 생성될 때 주어진 것이며, 객체가 살아 있는 동안 그대로 보존됩니다

자바 플랫폼 라이브러리에는 이런 클래스가 많습니다

String, 기본 자료형 클래스(byte, short, int, long, float, double, char, boolean), BigInteger, BigDecimal 등이 그런 클래스입니다

---

<h5>변경 불가능 클래스 만드는 이유</h5>

우선 변경 불가능 클래스는 변경가능 클래스보다 설계가 쉽고,

구현하기 쉬우며,

사용하기 쉽고,

오류 가능성도 적으며,

더 안전합니다

---

<h5>변경 불가능 클래스를 만들 때는 아래 다섯 규칙을 따르면 됩니다</h5>

객체 상태를 변경하는 메서드(수정자 메서드 등)를 제공하지 않습니다

계승할 수 없도록 합니다

그러면 잘못 작성되거나 악의적인 하위 클래스가 객체 상태가 변경된 것처럼 동작해서 변경 불가능성을 깨뜨리는 일을 막을 수 있습니다

계승을 금지하려면 보통 클래스를 final로 선언하면 됩니다. 물론 다른 방법도 있으며 뒤에서 설명될 예정입니다

모든 필드를 final로 선언합니다

그러면 시스템이 강제하는 형태대로 프로그래머 의도가 분명히 드러납니다

이러면 자바 메모리 모델에 명시된 바와 같이 새로 생성된 객체에 대한 참조가 동기화 없이 다른 스레드로 전달되어도 안전합니다

모든 필드를 private로 선언합니다

그러면 클라이언트가 필드가 참조하는 변경 가능 객체를 직접 수정하는 일을 막을 수 있습니다

(기본 자료형 값, 혹은 변경 불가능 객체에 대한 참조 필드를 public으로 선언하는 변경 불가능 클래스를 만드는 것이 기술적으로는 가능하지만 권하지는 않습니다. 나중에 클래스 내부 표현을 변경할 수 없기 때문입니다)

변경 가능 컴포넌트에 대한 독점적 접근권을 보장합니다

클래스에 포함된 변경 가능 객체에 대한 참조를 클라이언트는 흭득할 수 없어야 합니다

클라이언트가 제공하는 객체로 초기화해서는 안되고, 접근자 또한 그런 필드를 반환하면 안됩니다

따라서 생성자나 접근자, readObject 메서드 안에서는 방어적 복사본을 만들어여 합니다

지금까지 5가지 변경 불가 클래스 만들 때의 규칙에서 설명한 클래스의 상당수는 변경이 불가능 합니다

<h5>실제 사례코드/h5>

    public final class Complex {
      private final double re;
      private final double im;
    public Complex(double re, double im){
      this.re = re;
      this.im = im;
    }

    public double realPart() { return re; }
    public double imaginaryPart() { return im; }
    public Complex add(Complex c) {
        return new Complex (re + c.re, im + c.im);
    }
    public Complex subtract(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }
    public Complex multiply(Complex c) {
        return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
    }
    public Complex divide(Complex c) {
        double tmp = c.re * c.re + c.im * c.im;
        return new Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp);
    }
    @Override public boolean equals(Object o) {
        if ( o == this )
            return true;
        if ( ! ( o instanceof Complex ) )
            return false;
        Complex c =(Complex) o;
        // == 대신 compare 사용 이유 : 57p (float나 double 이외 기본 자료형은 == 연산자로 비교, float, double은 상수 문제로  따로 비교하는 방법이 있다)
        return Double.compare(re, c.re) == 0 && Double.compare(im, c.im) == 0;
    }
    @Override public int hashCode() {
        int result = 17 + hashDouble(re);
        result = 31 * result + hashDouble(im);
        return result;
     }
        private static int hashDouble(double val) {
        long longBits = Double.doubleToLongBits(val);
        return (int) (longBits ^ (longBits >>> 32));
     }
    @Override public String toString() {
          return "(" + re + " + " + im + "i)";
        }
    }

<h5>위 클래스 코드</h5>
이 클래스는 복소수(complex number, 즉 실수부와 허수부를 갖는 수)를 표현하는 클래스입니다

Object 클래스가 제공한느 메서드 외에도 실수부와 허수부 값을 가져오기 위한 접근자, 사칙 연산 각각에 대응되는 메서드를 제공하고 있습니다

사칙연산 각각은 this 객체를 변경하는 대신 새로운 Complex 객체를 만들어 반환하도록 구현되어 있음을 유의해야 합니다. 대부분의 변경 불가능 클래스가 따르는 패턴입니다. 함수형 접근법(?)으로도 알려져 있습니다. 피연산자를 변경하는 대신, 연산을 적용한 결과를 새롭게 만들어 반환하기 때문입니다

절차적 또는 명령형 접근법은 피연산자에 일정한 절차를 적용하여 그 상태를 바꿉니다. 함수형 접근법은 익숙하지 않는 사람에게는 부자연스러울 수 있지만 변경 불가능성을 보장하므로 장점이 많습니다


<h5>변경 불가능 객체는 단순합니다</h5>
생성될 때 부여된 한 가지 상태만 갖습니다. 따라서 생성자가 불변식을 확실히 따른다면, 해당 객체는 불변식을 절대로 어기지 않게 됩니다

반면 변경 가능한 객체의 상태는 까다롭게 바뀔 수 있습니다

수정자 호출 시 객체 상태가 어떻게 바뀌는지 정확하게 기술되어 있지 않은 변경 가능 클래스는 안정적으로 사용하기 어렵거나 사용이 불가능합니다

또한 변경 불가능 객체는 스레드에 안전할 수 밖에 없습니다. 여러 스레드가 동시에 사용해도 상태가 훼손될 일이 없습니다. 스레드 안정성을 보장하는 가장 쉬운 방법입니다

사실 스레드는 다른 스레드가 변경 불가능한 객체에 무슨 짓을 하는지 알 수 없습니다. 따라서 변경 불가능한 객체는 자유롭게 공유할 수 있습니다

<h5>변경 불가능 클래스는 클라이언트가 기존 객체를 재사용하도록 적극 장려해서 이런 장점을 충분히 살릴 필요가 있습니다</h5>

한 가지 쉬운 방법은, 자주 사용되는 값을 public static final 상수로 만들어 제공하는 것입니다

Complex 클래스는 아래와 같은 값들을 제공할 수 있습니다

    public static final Complex ZERO = new Complex(0, 0);

    public static final Complex ONE = new Complex(1, 0);

    public static final Complex I = new Complex(0, 1);

<h5>이 접근법은 한 단계 더 개선할 수 있습니다</h5>

변경 불가능 클래스는 자주 사용하는 객체를 캐시하여 이미 있는 객체가 거듭 생성되지 않도록 하는 정적 팩터리를 제공할 수 있습니다

기본 자료형에 대한 객체 클래스(boxed primitive class)들과 BigInteger 클래스는 그렇게 구현되어 있습니다. 이런 정적 팩터리 메서드를 사용하면 클라이언트는 새로운 객체를 만드는 대신 기존 객체들을 공유하게 되므로 메모리 요구량과 쓰레기 수집 비용이 줄어듭니다

새로운 클래스 설계 시 public 생성자 대신 정적 팩터리 메서드를 제공하면 나중에 클라이언트 코드를 변경하지 않고도 캐시 기능을 추가할 수 있습니다

변경 불가능한 객체를 자유롭게 공유할 수 있다는 것은, 방어적 복사본을 만들 필요가 없다는 뜻이기도 합니다

애초에 복사본을 만들 필요가 없다는 의미로, 만들어 봐야 원래 객체와 영원히 같은 상태이기 때문입니다

따라서 변경 불가능 클래스에 clone 메서드나 복사 생성자는 만들 필요도 없고, 만들어서도 안됩니다

자바 플랫폼 초창기에 이 사실을 올바르게 이해하지 못해 String 클래스는 복사생성자가 있습니다. 하지만 사용은 피해야 합니다
















