## 04장 ERD 기초 ##

<h3>ERD 기초</h3>

<h4>엔티티 정의</h4>

시스템 분석에는 기능분석을 진행합니다<br>
기능분석으로 구축할 시스템의 규모와 기능을 정리할 수 있습니다<br>
기능분석은 시스템 구축을 위한 최소 단위의 프로세스를 판별해 낼 수 있습니다<br>

<br>
일반적 엔티티 "존재하는 것"<br>
사물의 존재와 그것의 품질 사이에 구별을 짓습니다<br>
엔티티가 되기 위한 조건은 존재하는 것이 전부입니다<br>
어떤 것이 존재 한다는 것은 다른 entity로 부터 분리되었음을 암시합니다

<br>
<h4>엔티티 나누는 기준</h4>

> 유형 : 물리적 형태가 있으며 안정적으로 **지속적으로 활용이 가능한 형태**(학생, 사원)<br>
> 개념 : 물리적 형태가 있고 **개념적으로만 구성되는 형태**(상품, 조직)<br>
> 시간 : **업무의 흐름으로 인해 발생**하는 형태(계약, 사고, 지도 점검)

<br>
<h4>모델링 준비 시 실제 중요한 것</h4>

모델링은 **정규화 고려도 중요하지만 더 중요한 건 업무**다. 분석, 설계자가 업무의 요건 등을 정확히 알고 모델러와 긴밀하게 협의 해가며 모델링을 해야한다고 저자는 강조하고 있다

<br>
<h4>ERD 관계</h4> 

두 개 이상의 엔티티 간 관계가 N : M (다대다) 경우라면 **다대다 관계 해소를 위한 목적**으로 인위적 교차 엔티티로 1 : M 관계 형성이 필요하다

> 예를들어<br>
> 임직원 정보 : 이름, 입사일, 경력, 연봉, 직책, 팀<br>
> 입사일, 경력, 연봉 각각의 데이터들만 조회할 수 있도록 만든다<br>
> 입사잍 테이블, 경력 테이블, 연봉 테이블, 팀 테이블<br>
> 각 테이블을 두면 원하는 정보만 조회할 수 있다

<br>
<h4>ERD 관계 그리기</h4>

ERD : 입사일Table >|0 --- |- 임직원 정보(사번, 입사일, 경력, 연봉...)<br>
ERD : 경력Table >|0 --- |- 임직원 정보(사번, 입사일, 경력, 연봉...)

<br>
<h4>엔티티 식별</h4>

기능 분석은 우선 개발해야 할 필요한 시스템이 가져야할 기능을 Tree 구조로 도식화 정리한 것이다<br>
상위에서 하위 개념으로 개발해야 할 시스템 기능 구성을 보다 쉽게 정리할 수 있다<br>
또한 기능 설계를 통해 작성된 Tree는 개발 일정 산출의 근거가 된다<br>
> Tree 구조에서 가장 낮은 단계가 바로 **시스템 구축하기 위해 필요한 최소단위의 '프로세스'**다. 우선 단위 프로세스를 분석하게 되면 엔티티 도출은 상당히 쉬워진다

<br>
<h4>Tree 구조 도식화</h4>

- [관리자 페이지] 
	- [회원관리]
		- [회원조회]
			- [어떤 프로세스]
		- [블랙리스트추가]
			- [어떤 프로세스]
	- [매출관리]
		- [인건비조회]
		- [재료비조회]
	- [재고관리]
		- [재고주문]
		- [재고조회]
	
<br>
<h4>식별자 정의</h4>

주식별자 정의는 전체 데이터 모델의 **복잡성 결정**의 중요한 요소
- 해당 업무에서 **자주 이용되는 속성을 주식별자로** 지정한다

- 속성값의 길이가 **가변적인 속성은 주식별자로 적당하지 않다**
	- Ex : **부서이름 보다 부서코드**를 주식별자로 지정하다

- 속성값이 자주 변하는 속성은 주식별자로 적당하지 않다
- 주식별자를 선정하기 위한 **속성 수를 적게** 하자
- 주식별자에 **Null 데이터가 들어와서는 안된다**

---
<br>
<h3>정규화</h3>
관계형 데이터베이스 모델링에 필수 작업

<h4>정규화란</h4>
데이터 모델을 보다 효과적으로 개선시키는 과정
고유 식별자 (primary key)를 가지는 개체에 대해 더 이상 분리할 수 없는 상태로 나누는 과정

<br>
<h4>정규화 수준이 증가하면</h4>
데이터의 양은 줄고 데이터 갱신 속도는 빠르며 같은 자료가 여러 개체에 분산된 것보다 일관성유지가 쉽다

<br>
<h4>정규화 일반적목적</h4>
중복된 데이터를 삭제하는 것이 주 목적입니다

<br>
<h4>제 1 정규화</h4>
반복되는 속성들을 다른 개체로 나누어 분리하는 작업입니다<br>
또 다른 개체로 판단할 수 있는 속성을 분리하고 각 개체 속성들의 유일한 식별자(PK)를 갖게 됩니다<br>

<br>
부모 테이블의 식별자(PK)는 자식 테이블의 외부키(FK)와 연결(Join)됩니다<br>

- 모든 Attribute는 반드시 하나의 값만 가져야 합니다 (반복형태 X)
- 정규화가 이루어지고 나면 자식 엔티티로 분리됩니다

<br>
<h4>제 1 정규화 사례</h4>

제 1정규화 전 :

[전체TABLE] - 학번, 학과명, 과목명, 수강번호, 교수명

제 1 정규화 후:

[학생TABLE] **학번**, 학과명

[수강신청TABLE] **학번(FK)**,  과목명, 수강번호, 교수명

하나의 테이블에 모든 정보가 들어 있는 것 중 계속해서 발생할 수 있는 속성들은 다른 엔티티로 분리하였습니다

제 1 정규화에 의해 자식 엔티티로 분리되었습니다

<br>
<h4>제 2 정규화</h4>

모든 속성은 식별자에 직접적으로 의존적이면 안되며 이에 해당되지 않는 속성을 분리합니다

- 모든 속성은 반드시 UID(Unique Identifier) 전부에 종속되야 합니다
- 정규화가 이뤄지고 나면 부모 엔티티로 분리됩니다

<br>
<h4>제 2 정규화 사례</h4>

제 2 정규화 전 :

[수강신청] 학번, 수강번호, 학과명, 과목명, 교수명

제 2 정규화 후 :

[수강신청] **학번**, **수강번호(FK)**, 등록일, 평가내역

[과목] 수강번호, 과목명, 교수명

> **수강신청에 수강번호는** 종속 되나 학번에는 종속되지 않는 것을 확인 할 수 있습니다<br>
> 이런 속성(과목명, 교수명)들은 과목코드를 UID로 하는 부모 엔티티로 분리하여 새로 만들어 준다

제 2 정규화를 진행하면 중복되어 등록되는 데이터 항목 들이 따로 만들어지면서 중복되지 않는 데이터를 구성해서 데이터관리의 효율성을 높일 수 있습니다

<br>
<h4>제 3 정규화</h4>

식별자 이외 속성은 식별자가 아닌 다른 속성에 종속적이지 않아야 합니다

- UID 아닌 모든 속성 간에는 서로 종속될 수 없습니다
- **정규화가 이루어지고 나면 부모 엔티티로 분리**됩니다

<br>
<h4>제 3 정규화</h4>

제 3 정규화 전 :

[학과등록] 학번, 과목코드 / 과목명, 수강시작일, 수강종료일, 등록일자, 평가코드, 평가내역

제 3 정규화 후 :

[학과등록] 학번, 과목코드(FK) / 평가코드(FK), 등록일자

[과목] 과목코드 / 과목명, 수강시작일, 수강종료일

[평가] 평가코드 / 평가내역

평가코드와 평가내역을 보면 **평가내역이 평가코드에 종속적**이 다는 것을 확인할 수 있습니다<br>

같은 속성값에 종속된다는 이야기입니다<br>

이런 경우 **평가코드를 UID로** 하고 평가내역을 속성값으로 하는 **엔티티로 분리**하여 새로 만듭니다<br>

제 3 정규화를 진행하고 나면 제 2 정규화와 유사하게 **중복되어 등록되는 데이터 항목들이 따로 분리**되어 만들어집니다

<br>
<h4>역 정규화</h4>

정규화 수행 후 테이블 아주 세분화되어 분리됩니다<br>

이 경우 집계성 속성을 추출하려 하면 Join도 많아 오래 걸리며 데이터 범위도 많아 서능에 부하도 줄 수 있습니다<br>

이런 업무 프로세서가 통계성, OLTP(online transaction processing)성이든 간에 많이 존재한다면 이 경우 역정규화를 합니다<br>

- 자식 엔티티 합계성 속성이나 총 건수 등을 부모 엔티티에 속성으로 두는 것입니다

<br>
<h4>역 정규화 사례</h4>

[채무자] : **채권발생ID, 채무자관리번호** / 채무자구분코드, 채무차량번호, 채무자주소, **총환입금액, 총포기금액**<br>

[환입내역] : **채권발생ID(FK), 채무자관리번호(FK), 환입일자** / 지역이자, **환입금액**, 승인여부<br>

[채무포기품의] : **채권발생ID(FK), 채무자관리번호(FK), 품의번호** / 포기품의여부, 포기사유코드, **포기금액**, 지연이자<br>

환입내역의 환입금액의 총환입금액을 채무자 엔티티의 속성으로 두어 빈번하게 발생되는 총환입금액을 조회 시 환입내역을 모두 조회하지 않고 채무자의 총환입금액만 조회하여 처리할 수 있도록 했다. 총포기금액도 같은 맥락이다<br>

> 역정규화 시 주의점 : 환입금액과 포기금액이 발생하면 환입내역이나 채무포기품의 엔티티에 자료가 발생되면서 **환입금액과 포기금액 삽입이 발생**합니다. 여기서 **채무자 엔티티의 역정규화한 총환입금액과 총포기금액의 데이터도 업데이트**를 해줘야 합니다

<br>
<h4>업무에 종속적이어야 한다</h4>

정규화 수행 후 꼭 집어보아야 할 것은 정규화된 테이블들이 업무에 종속적으로 되어 있는가 봐야 합니다<br>

이 뜻은 정규화 보다 업무에서 발생되는 데이터의 발생 규칙이 더 중요하기 때문입니다<br>

정규화를 잘 해두었지만 **데이터가 그렇게 발생되지 않는다고 하면 모두 헛고생**을 한 것이기 때문에 모델링 시 정확한 업무를 파악하고 모델링을 실시해야 합니다<br>

---
<br>
<h3>릴레이션</h3>

**엔티티와 엔티티 간 하나 이상의 관계**가 존재할 수 있습니다. 엔티티가 단 100개만 되어도 1만 가지의 관계가 발생할 수 있습니다. 만야 엔티티 개수가 1000개라면 얼마나 되겠는가?<br>

이것들은 **오류없이 정확하게 정의해야** 하지만 생각처럼 쉽게 접근할 수 없다<br>

**이 단계의 보다 용이한 접근은 관계상관도**를 이용하는 것이다<br>

릴레이션의 내용을 명확하게 정의하는 작업을 합니다. 이들을 하나로 묶을 수도 있고 세분화 시킬 수도 있습니다. 이 결정이 나중에 미치는 영향을 정말 방대합니다<br>

<br>
<h4>관계 정의</h4>

- 공백 : 부모와 자식 사이에 0, 1, 다수의 관계
- P : 부모와 자식 사이에 1, 다수의 관계
- Z : 부모와 자식 사이에 0, 1 관계
- Exactly n : 부모와 자식 사이에 정확히 N개인 관계

비식별(Non-Identifying) : - - - <br>
식별(Identifying) : --- <br>

<br>
꼭 존재해야 하는(mandatory) : "|"<br>
존재해도 되는(optional) : "O"<br>
여러 개 존재할 수 있는 : "<"<br>

> 예를들면 : [업체]|o - - - o|<[인사마스터]<br> 
> 인사마스터에서 업체를 정의 해보면 인사마스터는 업체를 가질 수도 있고 한 개 가질 수도 있다<br>
 
> 예를들면 : [인사마스터]> --- <[장비]<br>
> N : M 관계로 "사원은 여러 개의 장비를 가지고 있다", "장비는 여러 명의 사원에 지급될 수 있다"라고 정의할 수 있습니다<br>

릴레이션은 이렇게 하나하나 짚어 가며 해석하는 버릇을 갖고 연습해야 나중에 ERD를 보고 해석하는 능력이 배양되면서 더 좋은 설계를 할 수 있게 될 것입니다<br>

<br>
<h4>ERD 물리적 변경</h4>

엔티티는 물리적 테이블로 변경됩니다

- 테이블명은 엔티티의 한글명을 영문으로 전환하여 사용하는 것이 좋습니다
- 영문명이 길어질 때는 프로젝트 용어규칙에 맞는 약어를 사용하여 작성합니다

엔티티의 속성은 테이블의 컬럼으로 변경됩니다

- 속성명 또한 한글명을 영문으로 전환하여 사용하는 것이 좋습니다
- 영문명이 길어질 때는 프로젝트 용어규칙에 맞는 약어를 사용해야 합니다

UID는 PK로 변경됩니다

- UID의 속성이 여러개면 PK1, PK2 등으로 나누어 결합 인덱스로 생성되며 Unique 인덱스로 생성됩니다
- 결합 인덱스일 때 컬럼의 순서 결정은 조회 조건에 많이 나오는 컬럼 순으로 나열하면 유리합니다

릴레이션은 FK로 변경됩니다

- 실선으로 표시되는 mandatory 관계일 때는 Not  null을 주면서 FK로 생성하며 점선으로 표시되는 Optional일 때는 Null을 허용할 수 있도록 생성합니다

<br>
<h4>FK생성 이슈</h4>

> 참고사항 : ERD 상에 릴레이션이 연결된 속성들을 모두 물리적으로 FK 생성해 줘야 하는지에 대한 이슈가 있다 <br>

> 모두 FK 한다면 개발이 진행되지 않고 (데이터 정합성 완전히 맞춰 가며 테스트 데이터를 만들어야 합니다) 프로젝트 완성 후에도 FK 때문에 에러가 종종 발생합니다. 이유는 물리적으로 있어야 할 데이터가 없을 때 FK 관련 레코드가 발생하면 에러가 발생하기 때문입니다 <br>

꼭 필요한 곳에는 FK를 설정하며 나머지는 프로그램에서 제어할 수 있도록 해주는 것이 좋은 방법이기도 합니다 <br>

<br>
<h4>ERD 가독성</h4>

- 릴레이션이 겹치지 않도록 엔티티를 배치해야 합니다(선이 겹치지 않도록)

- 공통 업무성의 엔티티는 릴레이션을 만들지 않는 것이 좋습니다 <br>
> 예를들어 첨부파일, 우편번호, 공통 코드 같은 엔티티는 거의 전체적인 엔티티와 릴레이션을 갖습니다. 이 경우는 릴레이션을 만들지 않습니다 <br>

- ERD 그릴 때 한쪽에서 시작하여 펼쳐지는 구조로 작성하는 것이 가독성에도 좋습니다 <br>
> 중요 테이블을 중심으로 펼쳐지는 형태로 ERD를 작성하면 업무가 더 눈에 잘 들어옵니다 <br>

- 엔티티가 너무 많다면 A3, A4 용지에 맞게 업무별로 엔티티를 작성해 주는 것이 좋습니다 <br>
